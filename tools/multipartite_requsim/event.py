import numpy as np
from requsim.events import Event
import requsim.libs.matrix as mat
from requsim.libs.aux_functions import apply_m_qubit_map
from requsim.quantum_objects import MultiQubit


def _generate_GHZ_proj_function(num_qubits):
    z0s = [mat.z0] * num_qubits
    z0s = mat.tensor(*z0s)
    z1s = [mat.z1] * num_qubits
    z1s = mat.tensor(*z1s)
    ghz_psi = 1 / np.sqrt(2) * (z0s + z1s)
    proj = ghz_psi @ mat.H(ghz_psi)

    def proj_func(rho):
        return proj @ rho @ proj

    return proj_func


class ConnectBellsToGHZEvent(Event):
    """Connect multiple Bell pairs meeting at a station to a GHZ state.

    Note: if only two Bell pairs are specified this is equivalent to entanglement swapping.

    Additional information in return dict of resolve method:

    "output_state" : MultiQubit
        The final GHZ state generated by the connection operation.
    "connecting_station" : Station
        The station where the connection operation was performed.

    Parameters
    ----------
    time : scalar
        Time at which the event will be resolved.
    pairs : list[Pair or MultiQubit]
        The left pair and the right pair.
    station : Station
        The station where the entanglement swapping is performed.
    callback_functions : list of callables, or None
        these will be called in order, after the event has been resolved.
        Callbacks can also be added with the add_callback method.
        Default: None

    """

    def __init__(self, time, pairs, station, callback_functions=None):
        self.pairs = pairs
        self.station = station
        super(ConnectBellsToGHZEvent, self).__init__(
            time=time,
            required_objects=pairs + [qubit for pair in pairs for qubit in pair.qubits],
            callback_functions=callback_functions,
        )

    def __repr__(self):
        return (
            self.__class__.__name__
            + f"(time={self.time}, pairs={self.pairs}), "
            + f"station={self.station}, "
            + f"callback_functions={self._callback_functions}"
        )

    def __str__(self):
        return (
            f"{self.__class__.__name__} at time={self.time} using pairs "
            + ", ".join([x.label for x in self.pairs])
            + "."
        )

    def _main_effect(self):
        """Resolve the event.

        Performs a measurement to connect Bell pairs to a GHZ state.

        Returns
        -------
        dict
            The return_dict of this event is updated with this.
        """
        # some stuff here is written so in theory it should also work with MultiQubit and not only Pair objects
        all_qubits = [qubit for pair in self.pairs for qubit in pair.qubits]
        # assert every pair has exactly one qubit at the station
        for pair in self.pairs:
            assert [(qubit in self.station.qubits) for qubit in pair.qubits].count(
                True
            ) == 1
        # find qubits at station
        combining_indices = []
        combining_qubits = []
        leftover_qubits = []
        for idx, qubit in enumerate(all_qubits):
            if qubit in self.station.qubits:
                combining_indices += [idx]
                combining_qubits += [qubit]
            else:
                leftover_qubits += [qubit]
        # do state transformation
        num_pairs = len(self.pairs)
        proj_func = _generate_GHZ_proj_function(num_pairs)
        for pair in self.pairs:
            pair.update_time()
        total_state = mat.tensor(*[pair.state for pair in self.pairs])
        new_state = apply_m_qubit_map(
            map_func=proj_func, qubit_indices=combining_indices, rho=total_state
        )
        new_state = mat.ptrace(rho=new_state, sys=combining_indices)
        new_state = new_state / np.trace(new_state)
        output = MultiQubit(
            world=self.pairs[0].world,
            qubits=leftover_qubits,
            initial_state=new_state,
        )
        # cleanup
        for qubit in combining_qubits:
            qubit.destroy()
        for pair in self.pairs:
            pair.destroy()
        return {"output_state": output, "combining_station": self.station}


class MergeBellToGHZEvent(Event):
    pass
