import numpy as np
from requsim.events import Event
import requsim.libs.matrix as mat
from requsim.libs.aux_functions import apply_m_qubit_map
from requsim.quantum_objects import MultiQubit


def _generate_GHZ_proj_function(num_qubits):
    z0s = [mat.z0] * num_qubits
    z0s = mat.tensor(*z0s)
    z1s = [mat.z1] * num_qubits
    z1s = mat.tensor(*z1s)
    ghz_psi = 1 / np.sqrt(2) * (z0s + z1s)
    proj = ghz_psi @ mat.H(ghz_psi)

    def proj_func(rho):
        return proj @ rho @ proj

    return proj_func


def _generate_merge_proj_func(num_qubits):
    z0s = [mat.z0] * num_qubits
    z0s = mat.tensor(*z0s)
    z0s_minus_1 = [mat.z0] * (num_qubits - 1)
    z0s_minus_1 = mat.tensor(*z0s_minus_1)
    z1s = [mat.z1] * num_qubits
    z1s = mat.tensor(*z1s)
    proj = z0s @ mat.H(z0s) + mat.tensor(mat.z1, z0s_minus_1) @ mat.H(z1s)

    def proj_func(rho):
        return proj @ rho @ mat.H(proj)

    return proj_func


class ConnectBellsToGHZEvent(Event):
    """Connect multiple Bell pairs meeting at a station to a GHZ state.

    Note: if only two Bell pairs are specified this is equivalent to entanglement swapping.

    Additional information in return dict of resolve method:

    "output_state" : MultiQubit
        The final GHZ state generated by the connection operation.
    "connecting_station" : Station
        The station where the connection operation was performed.

    Parameters
    ----------
    time : scalar
        Time at which the event will be resolved.
    pairs : list[Pair or MultiQubit]
        The pairs that are going to be merged.
    station : Station
        The station where the connecting operation is performed.
    callback_functions : list of callables, or None
        these will be called in order, after the event has been resolved.
        Callbacks can also be added with the add_callback method.
        Default: None

    """

    def __init__(self, time, pairs, station, callback_functions=None):
        self.pairs = pairs
        self.station = station
        super(ConnectBellsToGHZEvent, self).__init__(
            time=time,
            required_objects=pairs + [qubit for pair in pairs for qubit in pair.qubits],
            callback_functions=callback_functions,
        )

    def __repr__(self):
        return (
            self.__class__.__name__
            + f"(time={self.time}, pairs={self.pairs}), "
            + f"station={self.station}, "
            + f"callback_functions={self._callback_functions}"
        )

    def __str__(self):
        return (
            f"{self.__class__.__name__} at time={self.time} using pairs "
            + ", ".join([x.label for x in self.pairs])
            + "."
        )

    def _main_effect(self):
        """Resolve the event.

        Performs a measurement to connect Bell pairs to a GHZ state.

        Returns
        -------
        dict
            The return_dict of this event is updated with this.
        """
        # some stuff here is written so in theory it should also work with MultiQubit and not only Pair objects
        all_qubits = [qubit for pair in self.pairs for qubit in pair.qubits]
        # assert every pair has exactly one qubit at the station
        for pair in self.pairs:
            assert [(qubit in self.station.qubits) for qubit in pair.qubits].count(
                True
            ) == 1
        # find qubits at station
        combining_indices = []
        combining_qubits = []
        leftover_qubits = []
        for idx, qubit in enumerate(all_qubits):
            if qubit in self.station.qubits:
                combining_indices += [idx]
                combining_qubits += [qubit]
            else:
                leftover_qubits += [qubit]
        # do state transformation
        num_pairs = len(self.pairs)
        proj_func = _generate_GHZ_proj_function(num_pairs)
        for pair in self.pairs:
            pair.update_time()
        total_state = mat.tensor(*[pair.state for pair in self.pairs])
        new_state = apply_m_qubit_map(
            map_func=proj_func, qubit_indices=combining_indices, rho=total_state
        )
        new_state = mat.ptrace(rho=new_state, sys=combining_indices)
        new_state = new_state / np.trace(new_state)
        output = MultiQubit(
            world=self.pairs[0].world,
            qubits=leftover_qubits,
            initial_state=new_state,
        )
        # cleanup
        for qubit in combining_qubits:
            qubit.destroy()
        for pair in self.pairs:
            pair.destroy()
        return {"output_state": output, "connecting_station": self.station}


class MergeToGHZEvent(Event):
    """Merge multiple Bell states or GHZ states to a single GHZ state.

    Leaving one qubit present at the central station where the merging is performed.

    Additional information in return dict of resolve method:

    "output_state" : MultiQubit
        The final GHZ state generated by the connection operation.
    "merging_station" : Station
        The station where the connection operation was performed.

    Parameters
    ----------
    time : scalar
        Time at which the event will be resolved.
    inputs : list[Pair or MultiQubit]
        The input states that will be merged.
    station : Station
        The station where the merging operation is performed.
    callback_functions : list of callables, or None
        these will be called in order, after the event has been resolved.
        Callbacks can also be added with the add_callback method.
        Default: None

    """

    def __init__(self, time, inputs, station, callback_functions=None):
        self.inputs = inputs
        self.station = station
        super(MergeToGHZEvent, self).__init__(
            time=time,
            required_objects=inputs
            + [qubit for input_state in inputs for qubit in input_state.qubits],
            callback_functions=callback_functions,
        )

    def __repr__(self):
        return (
            self.__class__.__name__
            + f"(time={self.time}, inputs={self.inputs}), "
            + f"station={self.station}, "
            + f"callback_functions={self._callback_functions}"
        )

    def __str__(self):
        return (
            f"{self.__class__.__name__} at time={self.time} using inputs "
            + ", ".join([x.label for x in self.inputs])
            + "."
        )

    def _main_effect(self):
        """Resolve the event.

        Performs a measurement to merge Bell pairs or GHZ states to a GHZ state.

        Returns
        -------
        dict
            The return_dict of this event is updated with this.
        """
        # assert every input has exactly one qubit at the station
        for input_state in self.inputs:
            assert [
                (qubit in self.station.qubits) for qubit in input_state.qubits
            ].count(True) == 1

        first_input = self.inputs[0]
        merging_qubits = []
        leftover_qubits = list(first_input.qubits)
        for idx, qubit in enumerate(first_input.qubits):
            if qubit in self.station.qubits:
                first_index = idx
                break
        new_state = first_input.state
        # maybe this whole thing could be transformed into some tensor transformation
        proj_func = _generate_merge_proj_func(num_qubits=2)
        for current_input in self.inputs[1:]:
            current_length = len(leftover_qubits)
            for idx, qubit in enumerate(current_input.qubits):
                if qubit in self.station.qubits:
                    additional_index = idx
                    merging_qubits += [qubit]
                else:
                    leftover_qubits += [qubit]
            second_index = current_length + additional_index
            new_state = mat.tensor(new_state, current_input.state)
            new_state = apply_m_qubit_map(
                map_func=proj_func,
                qubit_indices=[first_index, second_index],
                rho=new_state,
            )
            new_state = mat.ptrace(rho=new_state, sys=[second_index])
        new_state = new_state / np.trace(new_state)
        output = MultiQubit(
            world=self.inputs[0].world,
            qubits=leftover_qubits,
            initial_state=new_state,
        )
        # cleanup
        for qubit in merging_qubits:
            qubit.destroy()
        for current_input in self.inputs:
            current_input.destroy()
        return {"output_state": output, "merging_station": self.station}
